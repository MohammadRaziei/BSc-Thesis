\chapter{توضیح مختصری بر الگوریتم}\label{ch:alg}

در فصل \ref{ch:rl} در مورد مفاهیم \w{rl} بحث شد. مهمترین مفاهیم عبارتند از:
\begin{multicols}{3}
\begin{enumerate}
	\item \w{env} \item \w{agent} \item \w{env state} \item \w{agent state} \item \w{reward} \item \w{observ} 
\end{enumerate}
\end{multicols}

هدف در این پروژه این بود که یک \w{autocar} با استفاده از الگوریتم های \w{rl} ساخته شود. جزییات تئوری الگوریتم و جزییات فنی پروژه به ترتیب در بخش های 
\ref{ch:rl}
و
\ref{ch:fani}
آورده شده‌اند.
در این بخش به شبیه سازی و جزییات کار و تعریف پارامتر های این پروژه برداخته می‌شود.

\section{معرفی محیط شبیه سازی}

در ابتدا محیط شبیه سازی را معرفی می‌کنیم. جزییات فنی این محیط در \ref{ch:fani} و همچنین نحوه راه‌اندازی آن در بخش \ref{ch:resault|sec:launch} به‌صورت کامل مورد بحث قرار گرفته است. اگر آن محیط را باز کنید محیط مانند شکل 
\ref{fig:obs-1}
باز خواهد شد. این محیط دو آبجکت مهم دارد؛
\begin{alphinline}
	\item ماشین(اتومبیل)
	\item جاده
\end{alphinline}
(شکل \ref{fig:road-car-models}) 



\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{Figures/OBS/1}
	\caption{محیط شبیه سازی}
	\label{fig:obs-1}
\end{figure}


%HERE
\begin{figure}
	\centering
	\def\localheight{2cm}
	\subfigure[]{%
		\includegraphics[height=\localheight]{Figures/rzbinary/agent}
		\label{subfig:model-car}
	}
	\hspace*{0.5cm} % space between two figures
	\subfigure[]{%
		\includegraphics[height=\localheight]{Figures/rzbinary/road}
		\label{subfig:model-road}
	}
	\caption[]{%
	}
	\label{fig:road-car-models}
\end{figure}


چیزی که اهمیت دارد اندازه ها و نحوه تعریف محدوده هاست. شکل \ref{fig:road-car-total} اندازه‌ها و محدوده ها را مشخص کرده است. 
شکل \ref{subfig:road-car-redbox-w} نشان می‌دهد که این محدوده ها کاملا برروی یک دیگر منطبق نیستند. دلیل اصلی این موضوع عدم اهمیت تطبیق دقیق این دو می‌باشد. در بخشی که پشت ماشین قرار دارد این محدوده از $-4$ (کمی بیشتر از اندازه عرض لاین ها) شروع می‌شود. زیرا نیازی نیست بیشتر از این مقدار ماشین مورد بررسی به عقب برود تا متوجه شویم اشتباه در حال رفتن است. درحقیقت این مورد کمک می‌کند تا تعداد \w{step} ها را در هر \w{episode} اشتباه کاهش یابد. بخش های کناری نیز از $-11$ تا $+11$ محدود شده‌اند (بیشتر از عرض خود جاده) تا اگر نوسانی یافت به ماشین این اجازه داده شود تا به مسیر اصلب برگردد. 



\begin{note}
	ماشین در مبدا صفحه قرار دارد. از این رو اعداد منفی نسبت به همین ماشین نیز سنحیده می‌شوند.
\end{note}



\begin{figure}[b!]
	\centering
%	\def\localdata{}
	\subfigure[]{%
		\includegraphics[width=0.7\linewidth]{Figures/rzbinary/road-car-wh}
		\label{subfig:road-car-wh}
	}
	%  	\hspace*{1.5cm} % space between two figures
	\subfigure[]{%
		\includegraphics[width=0.7\linewidth]{Figures/rzbinary/road-car-redbox+-w}
		\label{subfig:road-car-redbox-w}
	}
	\caption[]{%
	}
	\label{fig:road-car-total}
\end{figure}

3 مقدار \lr{+w} ، \lr{-w} و \lr{0} که در شکل \ref{subfig:road-car-redbox-w} بر روی جاده نوشته شده است در حقیقت مرتبط با بحث فنی ماجرا می‌باشد اما مفهوم آن این است که \w{agent} مورد بررسی می‌تواند این سه لاین را به عنوان \w{action} اختیار کند. در حقیقت می‌توان آن‌ها را به عنوان اسم برای هر لاین در نظر گرفت. در مورد \w{action} بیشتر صحبت خواهد شد.

\begin{note}
	راه‌اندازی این محیط کمی دردسر خواهد داشت از این‌رو نیاز است پیش از راه‌اندازی بخش \ref{ch:resault|sec:launch} به‌طور دقیق مطالعه شود.
\end{note}





\section{معرفی \ws{api} و \ws{alg}}
%\section{تعریف کردن پارامتر های \ws{rl}}
%قبل از بررسی پارامتر های ‌\w{rl} مناسب است که شکل نهایی این الگوریتم همین ابتدا بررسی شود.
%\footnote{منظور از پارامتر های \w{rl} پارامتر هایی مانند تعیین \w{reward} و \w{state} می‌باشد.}
در این پروژه دو الگوریتم \gls{a:dqn} و \gls{a:a2c} بهتر از سایر الگوریتم ها عمل کردند اما در نهایت با توجه به آزمایش‌ها و ملاحظاتی که انجام شد، الگورینم \gls{a:dqn} از لحاظ سرعت همگرایی بهتر از الگوریتم \gls{a:a2c} پاسخ داد. بنابراین صرفا برروی این الگوریتم بحث خواهد شد.




\code[python, label={code:dqn.py}]{dqn-train.py}


این کد بخش \w{train} را نشان می‌دهد. بخش \w{test} در تمامی الگوریتم ها مشابه یک دیگر است و از جایی که مدل تعریف می‌شود (در اینجا خط 18) شروع خواهد شد. 

بخش \w{test} در تمامی الگوریتم ها کد زیر است.

\code{alg-test.py}

از روی چند خط آغازین کد
\hyperref[code:dqn.py]{\gls{a:dqn}}
می‌توان دریافت که این کد با استفاده از \lr{gym}\cite{git/gym} و \lr{stable-baseline}\cite{stable-baselines} نوشته شده است.

بخش مهم بعدی متغیری از جنس دیکشنری به نام \texttt{env\_dict} است. این متغیر برای ساختن متغیر \texttt{env} در دستور 
\lr{\texttt{env = gym.make(**env\_dict)}} 
به‌کار می‌رود.
\RTLfootnote{متغیر \texttt{env} در حقیقت نقش \w{env} را در الگوریتم دارد.}
 توضیح این متغیر و اجزای آن در جدول \ref{tab:env-dict} آمده است.
 
\begin{table}\tableset{
\begin{tabular}{|C{0.25\linewidth}|p{0.7\linewidth}|}
	\hline\rowcolor{lightgray}
	متغیر & توضیحات
	\\\hline
	\texttt{id} & در این پروژه این متغیر دو حالت بیشتر ندارد که هردو از جنس رشته هستند. اگر این کد با استفاده از \w{matlabengine} استفاده شود، \lr{\texttt{'prescan-v0'}} 
	خواهد بود و اگر از \w{matlabengine} استفاده نشده باشد مقدار آن 
	\lr{\texttt{'prescan-without-matlabengine-v0'}} 
	خواهد بود. 
	
	این متغیر مقدار پیش‌فرض ندارد.
	 \\\hline
	\texttt{verbose} & این متغیر که از جنس بولین می‌باشد، در صورتی که یک باشد اطلاعات جامعی را در هر \w{step} 
	را چاپ می‌کند. علاوه برآن اطلاعات آماری \w{reward}های بدست‌آمده در پایان هر \w{episode} را نیز چاپ می‌کند. به‌طور کلی اجازه گزارش دادن و ندادن اطلاعات درونی الگوریتم توسط این متغیر کنترل می‌شود.
	 \\\hline
	\texttt{host} & این متغیر برای اتصال شبکه بین دو کامپیوتر به کار می‌رود و در حقیقت \lr{IP} کامپیوتری است که ویندوز بر روی آن نصب است. مقدار پیش‌فرض این متغیر \texttt{'localhost'} می‌باشد. \\\hline
	\texttt{delay} & همان‌طور که مشخص است این متغیر مقدار تاخیر را مشخص میکنم و مورد کاربرد آن لحظه ای است که \texttt{action} در تابع \texttt{step} فرستاده شده است و پس از گذشت مقداری تاخیر برحسب ثانیه سعی در دریافت اطلاعاتی مانند \w{obs} بعدی و محاسبه \w{reward} و ... داریم. مقدار پیش‌فرض این متغیر نیز صفر است. \\\hline
	\texttt{nget} & این متغیر نیز به نوعی متفاوت تاخیر را شکل می‌دهد. این متغیر از نوع عدد صحیح می‌باشد و هنگامی که مقدار آن 150 است یعنی محل تاخیر، 150 بار داده‌ها را دریافت می‌کند و مقدار آن‌ها را می‌خواند. در حالت عادی تا پایان 150‌اُمین دریافت هیچ کاری نمی‌کند مگر این که مقدار \texttt{done} برابر یک شود؛ در این صورت حلقه را متوقف کرده و باقی عملیات را انجام می‌دهد. 
	مقدار پیش‌فرض این متغیر یک می‌باشد.
	\\\hline
	\texttt{experimant\_name} & این متغیر مربوط به تنظیمات \w{matlabengine} می‌باشد و به صورت عادی نیازی به تغییر مقدار پیش‌فرض آن نیست.\\\hline
	\texttt{close\_window} & این پارامتر درصورتی قابل اجراست که کد پایتون و نرم‌افزار \w{prescan} هردو بر روی یک کامپیوتر باشند و وظیفه آن این است که محیط گرافیکی را پس از اجرا شدن کد می‌بندد و مقدار پیش فرض آن صفر می‌باشد. \\\hline
\end{tabular}}
\caption{بررسی پارامتر های موجود در \texttt{env\_dict}}
\label{tab:env-dict}
\end{table}

همان‌طور که در جدول \ref{tab:env-dict} توضیح داده‌شده‌است؛ دو متغیر \texttt{nget} و  \texttt{delay} هر دو از جنس تاخیر می‌باشند. محل تاخیر در تابع \texttt{step} می‌باشد. کد زیر محل تاخیر را نشان می‌دهد.

\begin{latin}
\begin{lstlisting}
def step(self, action):	
	self.send(action)
	# -------- BEGIN --------
	if self.delay > 0 :
		sleep(self.delay)
	for _ in range(self.nget):
		self.render_()
		if self.done:
			break
	# --------- END -‌--------
	observation = self._next_observation()
	reward = self.calc_reward()
	done = self.done
	info = {'Collision':self.collision ,'Position':self.agent['data']['Position']}
\end{lstlisting}
\end{latin}

این کد که در حقیقت هسته اصلی
\RTLfootnote{این کد از آن جهت که کاملا با تابع اصلی برابر نمی‌باشد، واژه "هسته اصلی" برای آن در نظر گرفته شده است. تفاوت آن با کد اصلی برخی عملیات است که مرتبط با چاپ شدن اصلاعات در حال اجرا می‌باشد که به مقدار \texttt{verbose} مرتبط می‌شود.}
 تابع \lr{step} می‌باشد. در بین محدوده مشخص شده، تاخیر صورت می‌گیرد. همان طور که مشخص است این تاخیر بین فرستادن \w{action} و محاسبه پارامتر‌هایی مانند \w{reward} و \w{obs}(\w{state})
می‌باشد. 
\begin{note}
	علت اصلی وجود تاخیر، مهلت دادن به \w{agent} برای انجام \w{action} است.
\end{note}

دو متغیر \texttt{nget} و \texttt{delay} هردو وظیفه ایجاد تاخیر دارند که نحوه ایجاد این تاخیر با یک‌دیگر کاملا متفاوت است. همچنین این امکان نیز وجود دارد به صورت ترکیبی نیز این تاخیر را ایجاد کرد. هر کدام از این روش‌ها مزایا و معایب خاص خود را دارند.

مزیت مهم استفاده از \texttt{nget} این است که به‌صورت مداوم در‌حال دریافت اطلاعات از محیط شبیه‌سازی است. بنابراین در صورت رخ دادن اتفاق خاصی مانند تصادف کردن و یا از مسیر خارج شدن می‌تواند آن‌را به موقع تشخیص دهد و تصمیمات لازم را انجام دهد.
در صورتی که در زمانی که تاخیر ناشی از \texttt{delay} است، عملا در آن مدت ارتباط با محیط شبیه سازی قطع شده است و ممکن است رخ دادن موارد گفته شده یا بسیار دیر متوجه شود و یا اصلا متوجه نشود. 

به‌طور مثال درصورتی که دو ماشین با یکدیگر تصادف داشته باشند؛ اگر این رخداد سریعا تشخیص داده نشود، در این صورت احتمال دارد این دو ماشین از روی یک دیگر عبور کنند! و پس از عبور کردن این اطلاعات دریافت شود و برخوردی تشخیص داده نشود. از آن‌جا که برخورد بیشترین میزان تاثیر در \w{reward} دارد؛ بنابراین، این اتفاق تاثیرات خیلی مخربی می‌تواند بر الگوریتم بگذارد.

عیب اصلی روش \texttt{nget} نیز این است که یک مقدار مشخص ندارد و به پارامتر هایی از جمله سرعت شبکه نیز وابسته است. بنابراین اگر از یک شبکه به شبکه دیگر منتقل شود می‌تواند مقدار کاملا متفاوتی به خود گیرد که شاید مطلوب نباشد. اما به راحتی با عوض کردن مقدار این متغیر در لایه \w{alg} می‌توان این مشکل را حل کرد. بنابراین توصیه می‌شود از این متغیر استفاده شود.



به کد 
\hyperref[code:dqn.py]{\gls{a:dqn}}
برگردیم.
خط 18 این کد مدل را می‌سازد. چیزی که اهمیت دارد این است که پارامتر $\gamma$ چه مقداری انتخاب شود. در نسخه نهایی این مقدار روی $0.8$ تنظیم شده است. در مورد این متغیر در بخش \ref{ch:rl} و در مراجع \cite{Sutton1998} و  \cite{uclRL} بحث شده‌است.
در ابتدا این متغیر مقدار پیش‌فرض $0.99$ را داشت. پس از بررسی‌های انجام شده این مقدار به $0.8$ کاهش یافت.

\section{تعریف کردن پارامتر های \ws{rl}}
منظور از پارامتر‌های \w{rl} از متغیر‌های \w{action} و \w{state} و \w{reward} و ... تا تعریف برخی توابع می‌باشد. 
ابتدا کلیات توابع را بررسی کنیم و سپس وارد جزییات آن پارامتر ها می‌شویم.

توابع استفاده شده به دو دسته تقسیم می‌شوند.
\begin{alphinline}
	\item توابع اصلی 
	\item  توابع فرعی یا کمکی
\end{alphinline}.

توابع اصلی آن دسته از توابعی هستند که مختص به کتاب‌خانه \texttt{gym} هستند و قرار دادن آن ها به شکل صحیح آن، اجباری است. توابع کمکی آن دسته از توابعی هستند که در این توابع نقش های مشخصی را ایفا کردند ولی استفاده کردن از آن ها اجباری نداشته است. 

\begin{note}
	در صورت لزوم کاربر می‌تواند توابع فرعی را تغییر دهد تا خروجی مطلوب خود را حاصل کند اما در لایه الگوریتم صرفا از توابع اصلی استفاده می‌شود. زیرا هدف هم که استاندارد سازی کد می‌باشد با این موضوع سازگار است.
\end{note}



\begin{table}\tableset{
\begin{tabular}{|C{0.2\linewidth}|p{0.75\linewidth}|}
	\hline\rowcolor{lightgray}
	نام تابع & توضیحات
	\\\hline
	\texttt{\_\_init\_\_} &  این تابع علاوه بر تنظیم کردن برخی پارامترهای مرتبط به کلاس، اتصال کد پایتون به نرم افزار متلب را نیز برعهده دارد.  
	همچنین تعیین \w{obsspace} و  \w{actionspace} نیز بر‌عهده این بخش می‌باشد.
	\\\hline
	\texttt{step} &  این تابع همان \w{step} است که در بخش 
	\ref{ch:rl} مطرح شد. محل اصلی اجرای این تابع در داخل یک حلقه متناهی می‌باشد. این تابع \texttt{action} را به صورت ورودی می‌گیرد و متغیر‌هایی مانند \texttt{observation} ، \texttt{reward} ، \texttt{done} و \texttt{info} را خروجی می‌دهد. در مورد نحوه محاسبه این خروجی ها صحبت خواهد شد.
	  \\\hline
	\texttt{reset} &  این تابع \texttt{env} ،را ریست می‌کند و به عنوان خروجی \w{state} اولیه را بر‌می‌گرداند. موارد استفاده از این تابع معمولا در اول کد و در آخر هر \w{episode} می‌باشد. آخر هر \w{episode} هنگامی فرا می‌رسد که متغیر \texttt{done} که یکی از خروجی‌های تابع \texttt{step} است، یک شود. \\\hline
	\texttt{render} &  این تابع به صورت معمول کارهای گرافیکی را برعهده دارد. اما از آنجایی که عمل در پس زمینه طرح وجود دارد، پس کار اصلی آن گرفتن داده‌ها و منظم کردن آن‌ها می‌باشد. برای این کار از یک تابع کمکی به نام \texttt{render\_} استفاده می‌کند.  \\\hline
\end{tabular}}
\caption{راهنمای توابع اصلی \ws{api}}
\label{tab:gym-alg-env}
\end{table}


جدول \ref{tab:gym-alg-env}، توابع اصلی را نشان می‌دهد و جدول \ref{tab:aux-alg-env} نیز توابع کمکی را نشان می‌دهد.



\begin{table}\tableset{
\begin{tabular}{|C{0.2\linewidth}|p{0.75\linewidth}|}
\hline\rowcolor{lightgray}
&
\\\hline
\end{tabular}}
\caption{راهنمای توابع کمکی \ws{api}}
\label{tab:aux-alg-env}
\end{table}















\newlinef
\begin{minipage}{4.8cm}
\includegraphics[width=4.8cm]{Figures/joystick}
\label{fig:joystick}
\end{minipage}
\hspace*{0.5cm}
\begin{minipage}{10cm}
\code[python,label={code:joystick}]{action-translation.py}
\end{minipage}





