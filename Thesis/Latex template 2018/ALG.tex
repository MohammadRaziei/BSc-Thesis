\chapter{توضیح مختصری بر الگوریتم}\label{ch:alg}

در فصل \ref{ch:rl} در مورد مفاهیم \w{rl} بحث شد. مهمترین مفاهیم عبارتند از:
\begin{multicols}{3}
\begin{enumerate}
	\item \w{env} \item \w{agent} \item \w{env state} \item \w{agent state} \item \w{reward} \item \w{observ} 
\end{enumerate}
\end{multicols}

هدف در این پروژه این بود که یک \w{autocar} با استفاده از الگوریتم های \w{rl} ساخته شود. جزییات تئوری الگوریتم و جزییات فنی پروژه به ترتیب در بخش های 
\ref{ch:rl}
و
\ref{ch:fani}
آورده شده‌اند.
در این بخش به شبیه سازی و جزییات کار و تعریف پارامتر های این پروژه برداخته می‌شود.

\section{معرفی محیط شبیه سازی}

در ابتدا محیط شبیه سازی را معرفی می‌کنیم. جزییات فنی این محیط در \ref{ch:fani} و همچنین نحوه راه‌اندازی آن در بخش \ref{ch:resault|sec:launch} به‌صورت کامل مورد بحث قرار گرفته است. اگر آن محیط را باز کنید محیط مانند شکل 
\ref{fig:obs-1}
باز خواهد شد. این محیط دو آبجکت مهم دارد؛
\begin{alphinline}
	\item ماشین(اتومبیل)
	\item جاده
\end{alphinline}
(شکل \ref{fig:road-car-models}) 



\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{Figures/OBS/1}
	\caption{محیط شبیه سازی}
	\label{fig:obs-1}
\end{figure}


%HERE
\begin{figure}
	\centering
	\def\localheight{2cm}
	\subfigure[]{%
		\includegraphics[height=\localheight]{Figures/rzbinary/agent}
		\label{subfig:model-car}
	}
	\hspace*{0.5cm} % space between two figures
	\subfigure[]{%
		\includegraphics[height=\localheight]{Figures/rzbinary/road}
		\label{subfig:model-road}
	}
	\caption[]{%
	}
	\label{fig:road-car-models}
\end{figure}


چیزی که اهمیت دارد اندازه ها و نحوه تعریف محدوده هاست. شکل \ref{fig:road-car-total} اندازه‌ها و محدوده ها را مشخص کرده است. 
شکل \ref{subfig:road-car-redbox-w} نشان می‌دهد که این محدوده ها کاملا برروی یک دیگر منطبق نیستند. دلیل اصلی این موضوع عدم اهمیت تطبیق دقیق این دو می‌باشد. در بخشی که پشت ماشین قرار دارد این محدوده از $-4$ (کمی بیشتر از اندازه عرض لاین ها) شروع می‌شود. زیرا نیازی نیست بیشتر از این مقدار ماشین مورد بررسی به عقب برود تا متوجه شویم اشتباه در حال رفتن است. درحقیقت این مورد کمک می‌کند تا تعداد \w{step} ها را در هر \w{episode} اشتباه کاهش یابد. بخش های کناری نیز از $-11$ تا $+11$ محدود شده‌اند (بیشتر از عرض خود جاده) تا اگر نوسانی یافت به ماشین این اجازه داده شود تا به مسیر اصلب برگردد. 



\begin{note}
	ماشین در مبدا صفحه قرار دارد. از این رو اعداد منفی نسبت به همین ماشین نیز سنحیده می‌شوند.
\end{note}



\begin{figure}[b!]
	\centering
%	\def\localdata{}
	\subfigure[]{%
		\includegraphics[width=0.7\linewidth]{Figures/rzbinary/road-car-wh}
		\label{subfig:road-car-wh}
	}
	%  	\hspace*{1.5cm} % space between two figures
	\subfigure[]{%
		\includegraphics[width=0.7\linewidth]{Figures/rzbinary/road-car-redbox+-w}
		\label{subfig:road-car-redbox-w}
	}
	\caption[]{%
	}
	\label{fig:road-car-total}
\end{figure}

3 مقدار \lr{+w} ، \lr{-w} و \lr{0} که در شکل \ref{subfig:road-car-redbox-w} بر روی جاده نوشته شده است در حقیقت مرتبط با بحث فنی ماجرا می‌باشد اما مفهوم آن این است که \w{agent} مورد بررسی می‌تواند این سه لاین را به عنوان \w{action} اختیار کند. در حقیقت می‌توان آن‌ها را به عنوان اسم برای هر لاین در نظر گرفت. در مورد \w{action} بیشتر صحبت خواهد شد.

\begin{note}
	راه‌اندازی این محیط کمی دردسر خواهد داشت از این‌رو نیاز است پیش از راه‌اندازی بخش \ref{ch:resault|sec:launch} به‌طور دقیق مطالعه شود.
\end{note}





\section{معرفی \ws{api} و \ws{alg}}
%\section{تعریف کردن پارامتر های \ws{rl}}
%قبل از بررسی پارامتر های ‌\w{rl} مناسب است که شکل نهایی این الگوریتم همین ابتدا بررسی شود.
%\footnote{منظور از پارامتر های \w{rl} پارامتر هایی مانند تعیین \w{reward} و \w{state} می‌باشد.}
در این پروژه دو الگوریتم \gls{a:dqn} و \gls{a:a2c} بهتر از سایر الگوریتم ها عمل کردند اما در نهایت با توجه به آزمایش‌ها و ملاحظاتی که انجام شد، الگورینم \gls{a:dqn} از لحاظ سرعت همگرایی بهتر از الگوریتم \gls{a:a2c} پاسخ داد. بنابراین صرفا برروی این الگوریتم بحث خواهد شد.




\code[python, label={code:dqn.py}]{dqn-train.py}


این کد بخش \w{train} را نشان می‌دهد. بخش \w{test} در تمامی الگوریتم ها مشابه یک دیگر است و از جایی که مدل تعریف می‌شود (در اینجا خط 18) شروع خواهد شد. 

بخش \w{test} در تمامی الگوریتم ها کد زیر است.

\code{alg-test.py}

از روی چند خط آغازین کد
\hyperref[code:dqn.py]{\gls{a:dqn}}
می‌توان دریافت که این کد با استفاده از \lr{gym}\cite{git/gym} و \lr{stable-baseline}\cite{stable-baselines} نوشته شده است.

بخش مهم بعدی متغیری از جنس دیکشنری به نام \texttt{env\_dict} است. این متغیر برای ساختن متغیر \texttt{env} در دستور 
\lr{\texttt{env = gym.make(**env\_dict)}} 
به‌کار می‌رود.
\RTLfootnote{متغیر \texttt{env} در حقیقت نقش \w{env} را در الگوریتم دارد.}
 توضیح این متغیر و اجزای آن در جدول \ref{tab:env-dict} آمده است.
 
\begin{table}\tableset{
\begin{tabular}{|C{0.25\linewidth}|p{0.7\linewidth}|}
	\hline\rowcolor{lightgray}
	متغیر & توضیحات
	\\\hline\hline
	\texttt{id} & در این پروژه این متغیر دو حالت بیشتر ندارد که هردو از جنس رشته هستند. اگر این کد با استفاده از \w{matlabengine} استفاده شود، \lr{\texttt{'prescan-v0'}} 
	خواهد بود و اگر از \w{matlabengine} استفاده نشده باشد مقدار آن 
	\lr{\texttt{'prescan-without-matlabengine-v0'}} 
	خواهد بود. 
	
	این متغیر مقدار پیش‌فرض ندارد.
	 \\\hline
	\texttt{verbose} & این متغیر که از جنس بولین می‌باشد، در صورتی که یک باشد اطلاعات جامعی را در هر \w{step} 
	را چاپ می‌کند. علاوه برآن اطلاعات آماری \w{reward}های بدست‌آمده در پایان هر \w{episode} را نیز چاپ می‌کند. به‌طور کلی اجازه گزارش دادن و ندادن اطلاعات درونی الگوریتم توسط این متغیر کنترل می‌شود.
	 \\\hline
	\texttt{host} & این متغیر برای اتصال شبکه بین دو کامپیوتر به کار می‌رود و در حقیقت \lr{IP} کامپیوتری است که ویندوز بر روی آن نصب است. مقدار پیش‌فرض این متغیر \texttt{'localhost'} می‌باشد. \\\hline
	\texttt{delay} & همان‌طور که مشخص است این متغیر مقدار تاخیر را مشخص میکنم و مورد کاربرد آن لحظه ای است که \texttt{action} در تابع \texttt{step} فرستاده شده است و پس از گذشت مقداری تاخیر برحسب ثانیه سعی در دریافت اطلاعاتی مانند \w{obs} بعدی و محاسبه \w{reward} و ... داریم. مقدار پیش‌فرض این متغیر نیز صفر است. \\\hline
	\texttt{nget} & این متغیر نیز به نوعی متفاوت تاخیر را شکل می‌دهد. این متغیر از نوع عدد صحیح می‌باشد و هنگامی که مقدار آن 150 است یعنی محل تاخیر، 150 بار داده‌ها را دریافت می‌کند و مقدار آن‌ها را می‌خواند. در حالت عادی تا پایان 150‌اُمین دریافت هیچ کاری نمی‌کند مگر این که مقدار \texttt{done} برابر یک شود؛ در این صورت حلقه را متوقف کرده و باقی عملیات را انجام می‌دهد. 
	مقدار پیش‌فرض این متغیر یک می‌باشد.
	\\\hline
	\texttt{experimant\_name} & این متغیر مربوط به تنظیمات \w{matlabengine} می‌باشد و به صورت عادی نیازی به تغییر مقدار پیش‌فرض آن نیست.\\\hline
	\texttt{close\_window} & این پارامتر درصورتی قابل اجراست که کد پایتون و نرم‌افزار \w{prescan} هردو بر روی یک کامپیوتر باشند و وظیفه آن این است که محیط گرافیکی را پس از اجرا شدن کد می‌بندد و مقدار پیش فرض آن صفر می‌باشد. \\\hline
\end{tabular}}
\caption{بررسی پارامتر های موجود در \texttt{env\_dict}}
\label{tab:env-dict}
\end{table}

همان‌طور که در جدول \ref{tab:env-dict} توضیح داده‌شده‌است؛ دو متغیر \texttt{nget} و  \texttt{delay} هر دو از جنس تاخیر می‌باشند. محل تاخیر در تابع \texttt{step} می‌باشد. کد زیر محل تاخیر را نشان می‌دهد.

\begin{latin}
\begin{lstlisting}
def step(self, action):	
	self.send(action)
	# -------- BEGIN DELAY --------
	if self.delay > 0 :
		sleep(self.delay)
	for _ in range(self.nget):
		self.render_()
		if self.done:
			break
	# --------- END DELAY -‌--------
	observation = self._next_observation()
	reward = self.calc_reward()
	done = self.done
	info = {'Collision':self.collision ,'Position':self.agent['data']['Position']}
\end{lstlisting}
\end{latin}

این کد که در حقیقت هسته اصلی
\RTLfootnote{این کد از آن جهت که کاملا با تابع اصلی برابر نمی‌باشد، واژه "هسته اصلی" برای آن در نظر گرفته شده است. تفاوت آن با کد اصلی برخی عملیات است که مرتبط با چاپ شدن اصلاعات در حال اجرا می‌باشد که به مقدار \texttt{verbose} مرتبط می‌شود.}
 تابع \lr{step} می‌باشد. در بین محدوده مشخص شده، تاخیر صورت می‌گیرد. همان طور که مشخص است این تاخیر بین فرستادن \w{action} و محاسبه پارامتر‌هایی مانند \w{reward} و \w{obs}(\w{state})
می‌باشد. 
\begin{note}
	علت اصلی وجود تاخیر، مهلت دادن به \w{agent} برای انجام \w{action} است.
\end{note}

دو متغیر \texttt{nget} و \texttt{delay} هردو وظیفه ایجاد تاخیر دارند که نحوه ایجاد این تاخیر با یک‌دیگر کاملا متفاوت است. همچنین این امکان نیز وجود دارد به صورت ترکیبی نیز این تاخیر را ایجاد کرد. هر کدام از این روش‌ها مزایا و معایب خاص خود را دارند.

مزیت مهم استفاده از \texttt{nget} این است که به‌صورت مداوم در‌حال دریافت اطلاعات از محیط شبیه‌سازی است. بنابراین در صورت رخ دادن اتفاق خاصی مانند تصادف کردن و یا از مسیر خارج شدن می‌تواند آن‌را به موقع تشخیص دهد و تصمیمات لازم را انجام دهد.
در صورتی که در زمانی که تاخیر ناشی از \texttt{delay} است، عملا در آن مدت ارتباط با محیط شبیه سازی قطع شده است و ممکن است رخ دادن موارد گفته شده یا بسیار دیر متوجه شود و یا اصلا متوجه نشود. 

به‌طور مثال درصورتی که دو ماشین با یکدیگر تصادف داشته باشند؛ اگر این رخداد سریعا تشخیص داده نشود، در این صورت احتمال دارد این دو ماشین از روی یک دیگر عبور کنند! و پس از عبور کردن این اطلاعات دریافت شود و برخوردی تشخیص داده نشود. از آن‌جا که برخورد بیشترین میزان تاثیر در \w{reward} دارد؛ بنابراین، این اتفاق تاثیرات خیلی مخربی می‌تواند بر الگوریتم بگذارد.

عیب اصلی روش \texttt{nget} نیز این است که یک مقدار مشخص ندارد و به پارامتر هایی از جمله سرعت شبکه نیز وابسته است. بنابراین اگر از یک شبکه به شبکه دیگر منتقل شود می‌تواند مقدار کاملا متفاوتی به خود گیرد که شاید مطلوب نباشد. اما به راحتی با عوض کردن مقدار این متغیر در لایه \w{alg} می‌توان این مشکل را حل کرد. بنابراین توصیه می‌شود از این متغیر استفاده شود.



به کد 
\hyperref[code:dqn.py]{\gls{a:dqn}}
برگردیم.
خط 18 این کد مدل را می‌سازد. چیزی که اهمیت دارد این است که پارامتر $\gamma$ چه مقداری انتخاب شود. در نسخه نهایی این مقدار روی $0.8$ تنظیم شده است. در مورد این متغیر در بخش \ref{ch:rl} و در مراجع \cite{Sutton1998} و  \cite{uclRL} بحث شده‌است.
در ابتدا این متغیر مقدار پیش‌فرض $0.99$ را داشت. پس از بررسی‌های انجام شده این مقدار به $0.8$ کاهش یافت.

\section{تعریف کردن پارامتر های \ws{rl}}
منظور از پارامتر‌های \w{rl} از متغیر‌های \w{action} و \w{state} و \w{reward} و ... تا تعریف برخی توابع می‌باشد. 
ابتدا کلیات توابع را بررسی کنیم و سپس وارد جزییات آن پارامتر ها می‌شویم.

توابع استفاده شده به دو دسته تقسیم می‌شوند.
\begin{alphinline}
	\item توابع اصلی 
	\item  توابع فرعی یا کمکی
\end{alphinline}.

توابع اصلی آن دسته از توابعی هستند که مختص به کتاب‌خانه \texttt{gym} هستند و قرار دادن آن ها به شکل صحیح آن، اجباری است. توابع کمکی آن دسته از توابعی هستند که در این توابع نقش های مشخصی را ایفا کردند ولی استفاده کردن از آن ها اجباری نداشته است. 

\begin{note}
	در صورت لزوم کاربر می‌تواند توابع فرعی را تغییر دهد تا خروجی مطلوب خود را حاصل کند اما در لایه الگوریتم صرفا از توابع اصلی استفاده می‌شود. زیرا هدف هم که استاندارد سازی کد می‌باشد با این موضوع سازگار است.
\end{note}



\begin{table}\tableset{
\begin{tabular}{|C{0.2\linewidth}|p{0.75\linewidth}|}
	\hline\rowcolor{lightgray}
	نام تابع & توضیحات
	\\\hline\hline
	\texttt{\_\_init\_\_} &  این تابع علاوه بر تنظیم کردن برخی پارامترهای مرتبط به کلاس، اتصال کد پایتون به نرم افزار متلب را نیز برعهده دارد.  
	همچنین تعیین \w{obsspace} و  \w{actionspace} نیز بر‌عهده این بخش می‌باشد.
	\\\hline
	\texttt{step} &  این تابع همان \w{step} است که در بخش 
	\ref{ch:rl} مطرح شد. محل اصلی اجرای این تابع در داخل یک حلقه متناهی می‌باشد. این تابع \texttt{action} را به صورت ورودی می‌گیرد و متغیر‌هایی مانند \texttt{observation} ، \texttt{reward} ، \texttt{done} و \texttt{info} را خروجی می‌دهد. در مورد نحوه محاسبه این خروجی ها صحبت خواهد شد.
	  \\\hline
	\texttt{reset} &  این تابع \texttt{env} ،را ریست می‌کند و به عنوان خروجی \w{state} اولیه را بر‌می‌گرداند. موارد استفاده از این تابع معمولا در اول کد و در آخر هر \w{episode} می‌باشد. آخر هر \w{episode} هنگامی فرا می‌رسد که متغیر \texttt{done} که یکی از خروجی‌های تابع \texttt{step} است، یک شود. \\\hline
	\texttt{render} &  این تابع به صورت معمول کارهای گرافیکی را برعهده دارد. اما از آنجایی که عمل در پس زمینه طرح وجود دارد، پس کار اصلی آن گرفتن داده‌ها و منظم کردن آن‌ها می‌باشد. برای این کار از یک تابع کمکی به نام \texttt{render\_} استفاده می‌کند.  \\\hline
\end{tabular}}
\caption{راهنمای توابع اصلی \ws{api}}
\label{tab:gym-alg-env}
\end{table}


جدول \ref{tab:gym-alg-env}، توابع اصلی را نشان می‌دهد و جدول \ref{tab:aux-alg-env} نیز توابع کمکی را نشان می‌دهد. همچنین لازم به ذکر است که 
\hyperref[code:standard-test]{کد تست استاندارد}
 این پروژه در به صورت زیر است:

\code[python,label={code:standard-test}]{standard-test.py}




\begin{table}\tableset{
\begin{tabular}{|C{0.25\linewidth}|C{0.16\linewidth}|p{0.54\linewidth}|}
\hline\rowcolor{lightgray}
نام تابع
&
محل استفاده
&
توضیحات
\\\hline\hline
\texttt{make}
&
\texttt{\_\_init\_\_}
&
\\\hline
\texttt{render\_}
&
\texttt{render} و 
\texttt{step} و 
\texttt{reset}
&
\\\hline
\texttt{send}
&
\texttt{step}
&
\\\hline
\texttt{calc\_reward}
&
\texttt{step}
&
\\\hline
\texttt{\_next\_observation}
&
\texttt{reset} و
\texttt{step}
&
\\\hline
\texttt{action\_translate}
&
\texttt{send}
&
\\\hline
\end{tabular}}
\caption{راهنمای توابع کمکی \ws{api}}
\label{tab:aux-alg-env}
\end{table}

\begin{note}
	این کد صرفا صحت عملکرد و نحوه استفاده از \w{api} را نشان می‌دهد و شامل هیچ گونه الگوریتمی نمی‌باشد.
\end{note}

\subsection{معرفی برخی توابع \ws{api}}



\begin{table}\tableset{
\begin{tabular}{|c|c|C{0.35\linewidth}|c|}
	\hline\rowcolor{lightgray}
	نام متغیر& مفهوم& جنس متغیر& توضیحات\\\hline
	\hline
	\texttt{action\_space} & \w{actionspace} & \lr{\texttt{spaces.Discrete(6)}} & عدد صحیح 6\\\hline
	\texttt{observation\_space} & \w{obsspace} & \lr{\texttt{spaces.Box(shape=(1,38), dtype=np.float16)}} & ماتریس 
	$1\!\times\!38$تایی \\\hline
\end{tabular}}
\caption{تعریف \w{obsspace} و  \w{actionspace} در پروژه}
\label{tab:spaces-alg}
\end{table}



\subsubsection{بررسی تابع \textbf{\texttt{action\_translation}:}}
این کد دقیقا پیاده سازی یک \w{joystick} می‌باشد. شکل \ref{fig:minipage-joystick} اطلاعات کامل این موضوع به همراه تفسیر آن ها دارد. 

از آنجایی که در این پروژه \w{actionspace} طبق جدول \ref{tab:spaces-alg} مقدار عدد صحیح 6 را دارد و این به آن معناست که 6 حالت گسسته بین صفر تا 5 برای \w{action} وجود دارد همچنین نشان می‌دهد که جنس \texttt{action} عدد صحیح \texttt{int} است. بنابراین، می‌بایست که آن را تفسیر کرد. وظیف اصلی این تابع نیز تفسیر مقدار مختلفی است که \texttt{action} می‌تواند بگیرد، می‌باشد.
 
%self.action_space = spaces.Discrete(6)
%self.observation_space = spaces.Box(low=0, high=255, shape= (1, 38), dtype=np.float16)





\newlinef
\begin{figure}
\begin{minipage}{4.8cm}
\centering
\includegraphics[width=4.8cm]{Figures/joystick}
\label{fig:joystick}
\newline
\tableset[1.5]{\begin{tabular}{c||c}
	شماره & وظیفه
	\\\hline\hline
	0 & رفتن به لاین \texttt{-w}\\
	1 & رفتن به لاین \texttt{0}\\
	2 & رفتن به لاین \texttt{+w}\\
	3 & زیاد کردن سرعت \\
	4 & کم کردن سرعت \\
	5 & یدون تغییر \\
\end{tabular}}
\end{minipage}
\hspace*{0.5cm}
\begin{minipage}{10cm}
\code[python,label={code:joystick}]{action-translation.py}
\end{minipage}
\caption{بررسی تابع \texttt{action\_translate}}
\label{fig:minipage-joystick}
\end{figure}

\begin{note}
	دستور کنترلی اصلی یک بردار دوتایی است (خط  18 کد شکل \ref{fig:minipage-joystick}) که مقدار اولی آن لاین را نشان می‌دهد و مقدار دوم آن سرعتی می‌باشد که انتظار داریم که \w{agent}، سرعت خود را به آن برساند. 
\end{note}
\begin{note}
	اگر دقت کنید در کد مذکور دو مقدار کنونی و قدیمی تر \texttt{action} نگه‌داری شده است.
\end{note}
\begin{note}
	همچنین دقت شود که در این کد، مقدار سرعت، همان مقدار حقیقی سرعت است که از محیط شبیه‌سازی می‌آید. و مقداری که در بردار \texttt{\_\_action\_\_} قرار می‌گیرد مقدار کنترلی سرعت است که با یک‌دیگر تفاوت دارند.
\end{note}


%\begin{latin}
%\begin{lstlisting}
%def action_velocity(vel,increase):
%	if increase:
%		return vel+5
%	else:
%		if vel < 5:
%			return vel/2
%		else:
%			return vel - 2
%\end{lstlisting}
%\end{latin}

نکته دیگری که حایز اهمیت است این است که هنگامی که گزینه 3 و یا 4 انتخاب می‌شوند، سیاستی برای افزایش و کاهش سرعت اتخاذ شده است. این سیاست در قالب یک تابع در تصاویر شکل \ref{fig:action-velocity-total} ظاهر شده است. همانطور که کد \ref{subfig:action-velocity-code} و نمودار متناظر آن در شکل \ref{subfig:action-velocity-double} نشان می‌دهد، سیاست های مختلفی برای زیاد کردن و کم کردن سرعت اتخاظ شده است. 

برای زیاد کردن سرعت، سرعت واقعی که از محیط شبیه سازی دریافت شده است با 5 واحد جمع می‌شود. بنابراین انتظار داریم سرعت پس از سه بار افزایش به 15 برسد (شکل \ref{subfig:action-velocity-inc}، نمودار قرمز) اما این اتفاق نمی‌افتد. زیرا این افزایش سرعت، کار زمان‌بری است و 
نیاز به حوصله دارد که اگر حوصله و تحمل و به عبارت دیگر تاخیر را از یه حدی بالاتر ببریم عملا در کنترل \w{agent} به مشکل خواهیم رسید. 

همچنین مورد مشابه آن چه که گفته شد، در شکل \ref{subfig:action-velocity-dec} نیز برقرار است. نقاطی که رنگشان قرمز است نمودار ایدآلی مفروض خواهند بود که معادل تاخیر کم سیستم جهت اعمال سرعت نهایی است. و نمودار دیگر معادل رخدادی است که $30\%$ به آن عمل شده است و $70\%$ تحت تاثیر مقدار قبلی خواهد بود و به این صورت یک میانگین وزن‌دار گرفته شده‌است.

\begin{figure}
\centering
\subfigure[کد اصلی روند افزایشی و یا کاهشی سرعت]{%
\includegraphics[height=3.7cm]{Figures/code/action-velocity-code2}
\label{subfig:action-velocity-code}
}
\hspace*{0.5cm} % space between two figures
\subfigure[شکل کلی نمودار افزایش سرعت]{%
\includegraphics[height=4cm]{Figures/code/action-velocity-double}
\label{subfig:action-velocity-double}
}
%	\hspace*{0.5cm} % space between two figures
\subfigure[حرکت در جهت افزایش سرعت با شروع از صفر]{%
\includegraphics[height=5cm]{Figures/code/action-velocity-inc}
\label{subfig:action-velocity-inc}
}
\subfigure[حرکت در جهت کاهش سرعت با شروع از 10]{%
\includegraphics[height=5cm]{Figures/code/action-velocity-dec}
\label{subfig:action-velocity-dec}
}
%	\hspace*{0.5cm} % space between two figures
\caption[]{%
}
\label{fig:action-velocity-total}
\end{figure}

مشاهده می‌شود که مسیری که به واقعیت نزدیک‌تر است آرامتر از مسیر مدنظر است. همچنین تفاوت تغییر روند کاهشی سرعت های کمتر از 5 واحد، این است که هیچ گاه منفی نشود ولی به صورت نمایی کاهش یابد و نزدیک صفر شود.

 تفاوت دیگر آن است که به هنگام افزایش مقدار 5 واحد به سرعت افزوده می‌شود و در هنگام کاهش مقدار دو واحد (برای سرعت های بالای 5 واحد) از آن کسر می‌شود. این تفاوت در مقایسه فاصله نقاط بین دو نمودار شکل‌های \ref{subfig:action-velocity-inc} و  \ref{subfig:action-velocity-dec} نیز ظاهر شده است. علت اصلی این تفاوت در بررسی \texttt{calc\_reward} خود را نشان می‌دهد. اما پیشتر در نظر داشته باشید که یک سیاست چهت‌دار و تشویقی جهت قرار گرفتن سریع‌تر در مسیر درست می‌باشد.
 
\subsubsection{بررسی تابع \textbf{\texttt{step}:}}

کد این تابع را پیش تر بررسی شد. جایگاه این تابع داخل 
\hyperref[code:standard-test]{کد تست استاندارد}
در داخل یک حلقه است هنگامی که حلقه تمام شود به اصلاح یک \w{episode} تمام شده‌است. دلیل تمام شدن حلقه یا رسیدن به سقف تعداد \w{step} در هر \w{episode} است و یا یک شدن مقدار \texttt{done}. این مقدار یکی از خروجی هایی است که این متغیر می‌تواند اختیار کند.
 
این تابع مقدار \w{action} را می‌گیرد. سپس آن را برای محیط شبیه سازی می‌فرستد. در کد زیر این کار توسط تابع \texttt{send} انجام می‌پذیرد. در تابع \texttt{send} ابتدا با استفاده از تابع \texttt{action\_translate} به صورت دستور کنترلی در خواهد آمد و پس از این تبدیل برای محیط شبیه سازی ارسال می‌شود.

پس از مقداری تاخیر،




\begin{latin}
\begin{lstlisting}
def step(self, action):	
	self.send(action)
	# -------- BEGIN DELAY --------
	if self.delay > 0 :
		sleep(self.delay)
	for _ in range(self.nget):
		self.render_()
		if self.done:
			break
	# --------- END DELAY -‌--------
	observation = self._next_observation()
	reward = self.calc_reward()
	done = self.done
	info = {'Collision':self.collision ,'Position':self.agent['data']['Position']}
\end{lstlisting}
\end{latin}













\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{Figures/code/reward-velocity}
	\caption{نمودار تابع محاسبه \w{reward} سرعت نرمال شده}
	\label{fig:reward-velocity}
\end{figure}





