\chapter{ نحوه پیاده سازی}\label{ch:fani}

این بخش لایه هایی را مطرح می‌کند که جهت پیاده سازی پروژه از آن استفاده شده است. لایه ای که به الگوریتم مرتبط می‌شود در بخش \ref{ch:alg} به صورت کامل بررسی خواهد شد و در این قسمت نحوه کارکردن محیط شبیه‌سازی مطرح خواهد شد.




\section{روش پیاده‌سازی}
همان‌طور که گفته شد، در این پروژه از ابزار های مختلفی استفاده شده است. البته جهت ایجاد اتصال بین آن ابزار ها نیز از برخی ابزار دیگر نیز استفاده شده‌است. در این بخش، این اجزا به تفصیل بررسی خواهد شد.

هر کدام از این اجزا کار مشخصی را بر عهده دارند.
شکل  
\ref{fig:block-diagram}
این ارتباط را نشان می‌دهد.

\begin{figure}[h!]
	\centering
	\includegraphics[width=1\linewidth]{Figures/block-diagram-white}
	\caption{بلوک دیالگرام لایه های کلی}
	\label{fig:block-diagram}
\end{figure}

در شکل 
\ref{fig:block-diagram}
از سمت چپ به راست اجزا یاد شده و نحوه ارتباط آن‌ها را به‌خوبی نشان می‌دهد. این بلوک ها و ارتباط ها عبارتند از:

\begin{itemize}
	\item 
	اولین بلوک آن، نرم افزار \textbf{پری‌اسکن }می‌باشد. وظیفه اصلی این نرم افزار، شبیه سازی دینامیک یک اتومبیل و یا موتور و ... می‌باشد. همچنین ایجاد یک محیط گرافیکی زیبا و یک پنل کاربری گرافیکی برای ساخت ماشین ها از دیگر حسن های این نرم افزار است.
	
	فایل های مهم ایجاد شده توسط این بخش، \texttt{.pex} و \texttt{.pb} می‌باشد.
	
	\item
	بلوک بعدی ترکیبی از \textbf{متلب و سیمولینک }است. چرا که نرم افزار پری‌اسکن این امکان را دارد که برای کنترل و دسترسی بیشتر به قسمت های کنترلی مختلف، رابطی به نام \lr{API} ارائه دهد. این \lr{API} یک فایل سیمولینک را در اختیار کاربران قرار می‌دهد که در آن بلوک های مشخصی به یکدیگر متصل هستند و با مطالعه و تغییر آن بلوک ها می‌توان کنترل سیستم را به دست گرفت.
	
	فایل های مهم این بخش نیز در فرمت \texttt{.slx} و \texttt{.m} در دسترس هستند.
	
	همچنین \api یاد شده، دستورات دیگری را جهت دریافت داده های استاتیک محیط ساخته شده در این نرم افزار را به کاربران خویش در محیط متلب می‌دهد.
	
	\item
	دو بلوک بعدی، مربوط به اتصال بین متلب و یا سیمولینک با پایتون هستند. 
	
	بلوک بالایی این اتصال را بین داده های استاتیک شامل طول جاده و عرض هر لاین، موقعیت اولیه اتومبیل و جاده (و همچنین بسیاری اطلاعات دیگر که بسیاری از آن اطلاعات استفاده نشده اند، زیرا در این پروژه مفید نبوده اند)، برقرار می‌سازد. این بلوک، فایل سیمولینک را تغییر نمی‌دهد.
	
	بلوک پایینی نیز با استفاده از روش های شبکه کردن، می‌تواند داده های پویا را از محیط سیمولینک به پایتون منتقل کند. این داده های پویا عبارتند از موقعیت و سرعت و اطلاعات دیگری از اتومبیل در حال حرکت، اطلاعات سنسورها و ... .
	
	\item 
	بلوک بعدی پایتون است که خود شامل لایه های دیگری است که در شکل 
	\ref{fig:python-layers}
	به تفضیل بیان شده است. نکته جالب در آن این است که در آن لایه ها اثری نیز از دو بلوک پیشین آمده است. همچنین بخش اصلی کار، یا به عبارتی مغز و هوش این کار در این قسمت توسعه یافته است.
\end{itemize}

\section{بررسی دقیق فایل سیمولینک}\label{ch:fani|sec:simulink}

فایل سیمولینک ایجاد شده توسط نرم افزار پری‌اسکن، قابلیت تغییر به دست کاربر را دارد. شکل 
\ref{fig:simulink-firstview}
فایل تغییر‌یافته مربوط به این پروژه را نشان می‌دهد.


\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{Figures/simulink/first_view}
	\caption{فایل سیمولینک ایجاد شده توسط نرم افزار پری‌اسکن همراه با تغییرات}
	\label{fig:simulink-firstview}
\end{figure}




بلوک های سمت راست نشان داده شده در سمت راست شکل
\ref{fig:simulink-firstview}
توسط نرم افزار پری اسکن ایجاد شده است که البته با اضافه کردن و تغییر بلوک های سیمولینک، آن را دست‌خوش تغییراتی نیز کرده ایم. 

در صورتی که با استفاده از محیط گرافیکی \lr{GUI} فایل \texttt{**.pex} تغییر کند، فایل سیمولینک تغییر نمی‌کند. در برخی موارد این تغییرات ممکن است منجر به پیغام خطا شود.

\begin{remark}\label{remark:Regenerate}
	در صورتی که فایل
	\texttt{**.pex}
	تغییر کند، برای اعمال این تغییرات، باید روی کلمه 
	\lr{Regenerate}
	که در شکل 
	\ref{fig:simulink-generate}
	آمده است، کلیک کرد. با این کار، تغییرات جدید اعمال می‌شود بی‌آن‌که تغییرات کاربر تحت تاثیر قرار بگیرد.
\end{remark}

\begin{figure}
	\centering
	\includegraphics[width=0.4\linewidth]{Figures/simulink/generate}
	\caption{روش صحیح اعمال تغییرات روی فایل سیمولینک}
	\label{fig:simulink-generate}
\end{figure}

در شکل 
\ref{fig:simulink-generate}
همانطور که در نکته
\ref{remark:Regenerate} 
به آن اشاره شد، دکمه ای تحت عنوان 
\lr{Regenerate}
وجود دارد که استفاده از آن در همان نکته مشخص شده است. همچنین در این تصویر در زیر لوگوی برنامه پری‌اسکن، اطلاعاتی مانند شماره نسخه نرم افزار (که در این‌جا \lr{8.5.0} می‌باشد.)، نام نویسنده مشاهده می‌شود.

در شکل 
\ref{fig:simulink-firstview}
اولین بلوک سمت راست همان ماشینی است که ما آن‌را تحت کنترل گرفته‌ایم. اگر به آن وارد شویم، شکل 
\ref{fig:simulink-agent}
را مشاهده می‌کنیم.
در این تصویر ورودی و خروجی ها نقش خیلی مهمی دارند. این اطلاعات در جدول
\ref{tab:simuink-agent-io}
آمده‌اند.



\begin{figure}[h!]
	\centering
	\includegraphics[width=1\linewidth]{Figures/simulink/agent}
	\caption{فایل سیمولینک - شبیه سازی اتومبیل}
	\label{fig:simulink-agent}
\end{figure}


\begin{table}[h!]
	\tableset{
		\begin{tabular}{|C{0.08\linewidth}|C{0.23\linewidth}|C{0.17\linewidth}|p{0.43\linewidth}|}
			\hline\rowcolor{lightgray}
			نوع & عنوان & بلوک مربوط & توضیحات
			\\\hline\hline
			خروجی &اطلاعات ماشین & \lr{SELF\_Demux} & اطلاعات ماشین، شامل اطلاعات موقعیت($x$،$y$ و$z$) و اطلاعات چرخش (حول $x$،$y$ و$z$) به همراه سرعت ماشین را خروجی می‌دهد. این 7 داده قبل از خروجی توسط یک \lr{mux} با یکدیگر ادغام می‌شوند.
			\\\hline
			خروجی& اطلاعات سنسور ماشین & \lr{AIR\_1\_Demux}  & اطلاعات سنسور \lr{V2C} را خروجی می‌دهد. از آنجا که این سنسور فاصله و زاویه و ...  تا ده ماشین نزدیک خود را می‌دهد. بنابراین هر‌یک از این اطلاعات یک بردار ده تایی است. برای فرستادن آن اطلاعات به خروجی، ابتدا آن‌ها را به  طریقی به فرمت جیسون
			\footnotemark%{json}
			تبدیل می‌کند و یک رشته کاراکتر با طول مشخص
			\footnotemark%{بعدا خواهید دید که مشخص بودن طول بسیار بسیار اهمیت دارد!}
			را خروجی می‌دهد.
			\\\hline
			ورودی & کنترل لاین و سرعت ماشین & \lr{PathFollower\_1} & دستورات کنترلی اتومبیل، شامل کدام خط بودن و مقدار سرعت نهایی، به صورت ورودی وارد یک \lr{demux} می‌شود و پس از جدا سازی، به بلوک مربوط متصل می‌شود.
			\\\hline
	\end{tabular}}
	\caption{بررسی ورودی ها و خروجی های مهم در شکل \ref{fig:simulink-agent}}
	\label{tab:simuink-agent-io}
\end{table}
\LTRfootnotetext[14]{json}
\RTLfootnotetext{بعدا خواهید دید که مشخص بودن طول بسیار بسیار اهمیت دارد!}


\subsection{معرفی بلوک 
	\lr{Environment}
	و بررسی جزییات آن
}

در جدول \ref{tab:simuink-agent-io} صرفا ورودی خروجی های مهم مورد بررسی قرار گرفته است. این ورودی ها و خروجی های مهم به یک بلوک دیگر منتقل می‌شود. بلوک 
\lr{Environment}
همان بلوک است که در شکل
\ref{fig:simulink-firstview}
نیز مشخص است و در شکل 
\ref{fig:simulink-env}
نیز از زاویه نزدیک تر با جزییات بیشتر می‌توان آن‌را مشاهده نمود.
%\code[matlab]{simulink-json-sensor.m}



\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{Figures/simulink/simulink-Env}
	\caption{نگاهی از نزدیک به بلوک \lr{Environmnet}}
	\label{fig:simulink-env}
\end{figure}




وظیفه اصلی بلوک 
\lr{Environment}
جمع آوری اطلاعات محیط سیمولینک و همچنین ارسال دستورات کنترلی به آن‌هاست. اطلاعات جمع آوری شده از محیط سیمولینک شامل موارد زیر است.

\begin{itemize}
	\item 
	اطلاعات ماشینی که نقش «عامل» را در الگوریتم دارد.
	\item 
	اطلاعات سنسور های ماشین «عامل»
	\item 
	اطلاعات مربوط به تصادف کردن و این‌که کدام ماشین با کدام ماشین تصادف کرده است.	
\end{itemize}

این اطلاعات به صورت ورودی به این بلوک وارد می‌شود و دستورات کنترلی شامل کنترل لاین ماشین به همراه مقدار سرعت نهایی ماشینی که نقش «عامل» در الگوریتم دارد، از این بلوک خارج می‌شود.

پیشتر صحبت شد که وظیفه تصمیم گیری بر عهده کد پایتون است. با این حساب سیمولینک قدرت تشخیص و تصمیم گیری ندارد. از این رو وظیفه بلوک 
\lr{Environment}
نیز تصمیم گیری نمی‌باشد بلکه با تکنیک هایی سعی بر برقراری ارتباط با کد پایتون دارد. در حقیقت این بلوک نقش واسط بین سیمولینک و پایتون را دارد. این بلوک علاوه بر دستورات کنترلی لاین و سرعت، دستور «شروع کردن دوباره» و یا ریست را نیز دریافت می‌کند. با این دستور تمامی اطلاعات به حالت اول بر خواهد گشت و ماشین «عامل» به جای اول بر خواهد گشت و منتظر دستورات جدید می‌ماند.

شکل 
\ref{fig:block-diagram}
توضیح بسیار کلی  در مورد این نحوه ارتباط نشان داده است و در شکل 
\ref{fig:inside-environment}
جزییات بیشتری را در مورد داخل این بلوک را نشان می‌دهد.


\begin{figure}
	\centering
	\includegraphics[width=0.95\linewidth]{Figures/simulink/inside-Environment}
	\caption{فایل سیمولینک - داخل بلوک \lr{Environment}}
	\label{fig:inside-environment}
\end{figure}

اگر به شکل 
\ref{fig:inside-environment}
دقت شود دو بلوک 
\lr{UDP}
دیده می‌شود. (بلوک 
\lr{UDP Send}
در بالا سمت راست و بلوک 
\lr{UDP Receive}
در پایین سمت چپ شکل 
\ref{fig:inside-environment}
)
این دو بلوک برای فرستادن داده های مورد نیاز به پایتون و گرفتن دستور های کنترلی از پایتون در سیمولینک تعبیه شده اند.

\begin{note}
	
	اگر نمودار شکل
	\ref{fig:block-diagram}
	در نظر داشته باشیم، خواهیم یافت که این بلوک در شاخه پایینی ارتباط بین سیمولینک و پایتون قرارا دارد که از روش های شبکه کردن بین این دو انجام می‌شود. این بلوک صرفا داده‌های پویا را از متلب به سیمولینک انتقال می‌دهد و با داده‌های استاتیک کاری ندارد. 
	
\end{note}

در جدول
\ref{tab:Reciver-Send}
اطلاعات دقیق شبکه برای این دو بلوک دیده می‌شود. گفتنی است که این داده ها به نحوه مناسب کد شده‌اند تا تنها با استفاده از این دو بلوک بتوان داده ها را منتقل کرد.


\begin{table}
	\tableset{
		\begin{tabular}{|c|c|c|c|}
			\hline\rowcolor{lightgray}
			نام بلوک & نوع بلوک & \lr{IP} & \lr{Port} 
			\\\hline\hline
			\lr{UDP Receiver} & گیرنده & \lr{localhost} & 8070 
			\\\hline
			\lr{Send Data} & فرستنده & \lr{localhost} & 8031 
			\\\hline
	\end{tabular}}
	\caption{اطلاعات بلوک های فرستندگی گیرندگی در سیمولینک}
	\label{tab:Reciver-Send}
\end{table}


روش کد شدن
\LTRfootnote{Encoding}
قبل از ارسال و یا دریافت در این دو بلوک کاملا با یکدیگر متفاوت هستند. این کار توسط بلوک‌های قبل و بعد دو بلوک مذکور انجام می‌شود. 



در شکل 
\ref{fig:inside-environment}
سه بلوک تابع متلب 
\LTRfootnote{Matlab-function block}
وجود دارد که از مهم‌ترین نقش را دارند. این نقش‌ها در ادامه توضیح توضیح مفصل داده شده‌اند.

خلاصه این وظایف در زیر آمده است:

\begin{itemize}
	\item \textbf{بلوک فرستنده} :
	این بلوک در سمت بالا سمت راست تمام اطلاعاتی که به بلوک کلی 
	\lr{Environment}
	وارد می‌شود را به نحوی مناسب به همراه متغیر \texttt{done} که از یک تابع متلب دیگر خارج می‌شود را برای پایتون طی ساختار مشخصی (جیسون) ارسال می‌کند.این موضوع، با جزئیات فراوان در بخش
	\ref{ch:fani|sec:simulink|sub:json}
	مورد بررسی قرار گرفته است.
	\item \textbf{بلوک گیرنده} :
	تنها وظیفه این بلوک، آن است که داده هایی که پس از بلوک \lr{Byte Unpacking} آمده است ، را انتخاب می‌کند که هر یک از این دیتا ها چه مفهومی هستند. از آن‌جا که ۳ داده کنترلی (لاین و سرعت و ریست) از طرف پایتون ارسال می‌شود، بلوک \lr{Byte Unpacking} وظیفه این ۳ داده را به فرمت \texttt{double} در می‌آورد (این فرمت در سمت پایتون نیز به همین شکل قرار داد شده‌است). بنابراین این بلوک \lr{Byte Unpacking} است که کار اصلی را انجام می‌دهد و تنها وظیفه این بلوک تفکیک و اسم گذاری بر‌روی خروجی بلوک \lr{Byte Unpacking} است.
	
	\item \textbf{بلوک محاسبه تمام شدن و ریست کردن} :
	این بلوک با دو خروجی مهم می‌دهد. یکی از آن خروجی ها \texttt{done} است که توسط بلوک فرستنده نیز برای پایتون ارسال می‌شود. و مقدار دیگری را که خروجی می‌دهد دستور ریست کردن است. این دستور در لبه مثبت (از صفر به یک برسد) ریست می‌کند. منطق این بلوک یک منطق باینری است که در شکل 
	\ref{fig:done-reset-logical}
	روش محاسبه آن نیز آمده است. 
	همچنین این بلوک یک مقدار به اسم \texttt{Auto\_reset\_flag} نیز به عنوان ورودی دریافت می‌کند. این مقدار که می‌تواند صفر و یا یک باشد، تصمیم می‌گیرد که در صورتی که \LRE{\texttt{done = 1}} شد آیا ریست کند و یا ریست نکند. اگر یک باشد ریست می‌کند وگرنه منتظر رسیدن دستور از پایتون می‌ماند.
	
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{Figures/done-reset-logical}
	\caption{منطق محاسبه تمام شدن و دستور ریست کردن}
	\label{fig:done-reset-logical}
\end{figure}


\subsection{بررسی ساختار داده های ارسالی  و کد آن در سیمولینک}\label{ch:fani|sec:simulink|sub:json}

بلوک فرستنده در شکل
\ref{fig:inside-environment}
اطلاعات دریافت شده را طی ساختار مشخصی به ساختار جیسون در می‌آورد.
نمونه ای از این ساختار در شکل
\ref{fig:block-diagram}
آمده است.
%\begin{figure}
%	\centering
%	\includegraphics[height=8cm]{Figures/simulink/json-env}
%	\caption{}
%	\label{fig:json-env}
%	\includegraphics[height=8cm]{Figures/simulink/json-sensor}
%	\caption{}
%	\label{fig:json-sensor}
%	\includegraphics[height=8cm]{Figures/simulink/json-total}
%	\caption{}
%	\label{fig:json-total}
%\end{figure}



%\begin{latin}
%\begin{lstlisting}[language=json]
%'{"Time":0,"Object":0,"Vehicles":[{"name":"Toyota_Yaris_Hatchback_1","data":{"Position":{"x":0.00000e+00,"y":0.00000e+00,"z":5.70000e-01},"Rotation":{"x":0.00000e+00,"y":0.00000e+00,"z":0.00000e+00},"Velocity":0.00000e+00},"Sensors":[{"name":"AIR_1","data":{"Range":[0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00],"theta":[0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00],"ID":[0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00],"Velocity":[0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00,0.00000e+00]}}]}],"Collision":{"Occurred":0,"col_1": 0,"cal_2": 0},"done":0}'
%\end{lstlisting}
%\end{latin}






\begin{figure}[h!]
	\centering
	\subfigure[اطلاعات خام جیسون کلی]{%
		\includegraphics[height=9cm]{Figures/simulink/json-env}
		\label{subfig:json-env}
	}
	%  	\hspace*{1.5cm} % space between two figures
	\subfigure[جیسون سنسور]{%
		\includegraphics[height=9cm]{Figures/simulink/json-sensor}
		\label{subfig:json-sensor}
	}
	%  	\\ % place in new line
	%  	\hspace*{1.5cm} % space between two figures
	\subfigure[شکل ادغام شده ]{%
		\includegraphics[height=9cm]{Figures/simulink/json-total}
		\label{subfig:json-total}
	}
	\caption[ساختار جیسون برای بلوک های سیمولینک]{%
		تصویر
		\subref{subfig:json-env}
		نحوه ساختار‌دهی کلی در بلوک تابع متلب واقع در زیرسیستم 
		\lr{Environment}
		را نشان می‌دهد. در این قسمت اطلاعات ماشین شامل دو قسمت \lr{data} و \lr{Sensors} است. اطلاعات سنسور های این ماشین  از تصویر \subref{subfig:json-sensor} تامین می‌شود. این ساختار در همان زیرسیستم ماشین تبدیل به جیسون شده و برای زیر‌سیستم \lr{Environmnet} ارسال می‌شود. قسمت سنسور یک آرایه است تا بتوان چندین سنسور مختلف را برای آن ارسال کرد. بنابراین ساختاری مانند تصویر \subref{subfig:json-total} باید را در نهایت برای پایتون ارسال می‌کند.
		\footnotemark
	}
	\label{fig:json-total}
\end{figure}
\RTLfootnotetext{این عکس با استفاده از سایت
	\lr{\href{http://jsonviewer.stack.hu/}{http://jsonviewer.stack.hu/}}
	تهیه شده است.}
شکل \ref{subfig:json-sensor} همان ساختاری است که پیشتر در مورد آن صحبت شد. با توجه به این که این ساختار (در ادامه خواهید دید که) در اطلاعات سنسور ماشین به کار گرفته می‌شود و هر سنسور ممکن است اطلاعات خاص خود را داشته باشد. برای یکسان‌سازی این اطلاعات، در اولین لایه دو گزینه \lr{data} و \lr{name} را به طور قرار دادی بین همه سنسور ها یکسان است تا در کد پایتون بتوان با توجه به اسم آن ها ادامه ساختار که در \lr{data} می‌باشد، قابل تشخیص باشد. اما از آن‌جا که صرفا از اطلاعات یک سنسور استفاده شده است این شکل ساختار‌دهی تنها یک گزینه برای توسعه های آتی آن است.

در این ساختار ۴ اطلاعات نشان داده شده که هر یک از آن اطلاعات خود یک بردار ۱۰ تایی است، برای پایتون ارسال می‌شود. 

شکل 
\ref{subfig:json-env}
ساختار کلی است که محیط \lr{Environmnet} از آن استفاده می‌کند. در این بلوک علاوه بر داده هایی مانند اطلاعات ماشین و سنسورش، اطلاعات تصادف و اطلاعات تمام شدن و یا نشدن شبیه سازی که پیش‌‌تر در مورد آن اطلاعات صحبت شد، دو اطلاعات اضافه دیگر نیز می‌فرستد.
\begin{itemize}
	\item \texttt{Time} :
	زمان شبیه سازی را همراه با دیتا دیگر ارسال می‌کند و به اصلاح یک ساختار زمانی ایجاد می‌شود.
	\LTRfootnote{Time-struct}
	\item \texttt{Object} :
	این عبارت کمک به کد پایتون می‌کند که ماشین هدف و یا عامل را از بین ماشین های موجود در لیست \texttt{Vehicles} بیابد. 
	\RTLfootnote{از آنجایی که در این پروژه  لیست \lr{Vehicles} یک آبجکت بیشتر ندارد، پس این بخش نیز صرفا ظرفیت توسعه‌پذیری این کد را بالا می‌برد.}
\end{itemize}

در نهایت با ادغام شدن اطلاعات سنسور نیز، ساختار کلی به شکل \ref{subfig:json-total} در خواهد آمد . در بخش
\ref{ch:fani|sec:chalenges}
از برخی از چالش های ساختاردهی کردن به این شکل، صحبت خواهد شد. همچنین خروجی نهایی آن نیز را می‌توانید در 
\hyperref[code:json]{همان بخش}
بیابید.

\section{بررسی جزییات بخش پایتون}\label{ch:fani|sec:python}
بخش اصلی تصمیم‌گیری برعهده بخش پایتون می‌باشد. در بخش 
\ref{ch:fani|sec:simulink}
سعی شد تا به نحو مناسبی دیتای محیط شبیه‌سازی را به پایتون منتقل کند و دستورات کنترلی را نیز از پایتون به محیط شبیه‌سازی ارسال کند. در این بخش به مفاهیم پایتونی آن، می‌پردازیم.

از آن‌جا که کد پایتون باید به سیمولینک متصل شود و دیتا را به الگوریتم کنترلی خود (که از الگوریتم های یادگیری تقویتی استفاده شده است) ، برساند و از آن جا دستورات را دریافت کند و به سیمولینک برساند، نیازمند لایه هایی است که هر لایه بخشی از این کار ها انجام دهد.

\subsection{معرفی لایه های کد پایتون}\label{ch:fani|sec:python|sub:layers}
کد پایتون از لایه های مختلف تشکیل شده است. از هر لایه به لایه بعدی سطح زبان بالاتر می‌رود. این لایه ها در شکل 
\ref{ch:fani|sec:python|sub:layers}
مشخص شده اند. در لایه های ابتدایی، سطح استفاده از دستورات بسیار ابتدایی است و در هر لایه با تعریف توابع و کلاس هایی این امکان را ایجاد کرده اند که بدون در نظر گرفتن این که در سطوح پایین‌تر چه اتفاقاتی می‌افتد، در سطوح بالاتر از آن امکانات استفاده کرد. در ادامه این بحث مفصل توضیح داده خواهد شد.



\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{Figures/python-layers-white}
	\caption{بلوک دیالگرام لایه های پایتون}
	\label{fig:python-layers}
\end{figure}
در شکل 
\ref{fig:python-layers}
۴ لایه برنامه نویسی شده با ۵ عدد نشان داده شده است. توضیحات زیر متناسب با هر‌یک از این شماره ها در نظر گرفته شده اند:




\begin{circlelist}
	\item \textbf{\lr{Model}} :
	در این لایه، با استفاده از موتور متلب با متلب و سیمولینک ارتباط برقرار می‌کند و با این ارتباط دو وظیفه بسیار مهم را انجام می‌دهد. 
	\begin{alphabetlist}
		\item 
		ساخت مدل هایی مانند اتومبیل و جاده و دریافت اطلاعات ضروری آن ها در متلب
		\item 
		تعریف کلاس \lr{sim} و ارسال دستوراتی مانند شروع کردن، توقف کردن، مکث کردن، ادامه دادن و ... به سیمولینک.
	\end{alphabetlist}
	این لایه صرفا از اطلاعات استاتیک سیمولینک استفاده می‌کند.
	
	\item \textbf{\lr{Environment}} :
	این لایه برای ارتباط با زیرسیستم \lr{Environment} که پیشتر آن‌را در شکل 
	\ref{fig:simulink-env}
	مشاهده کردید، ساخته شده است. در این لایه با استفاده از ابزار هایی که لایه 
	\lr{Model}
	در اختیار آن قرار می‌دهد، به سادگی آبجکت هایی ماند ماشین و جاده را می‌سازد و با استفاده از اطلاعات شبکه که در جدول 
	\ref{tab:Reciver-Send}
	آمده است، با سیمولینک ارتباط برقرار می‌کند و آن اطلاعات پویا را دریافت می‌کند و دستورات کنترلی را برای آن ارسال می‌کند.
	
	این لایه از موتور متلب استفاده نمی‌کند بلکه از روش های شبکه ای استفاده می‌کند. 
	\item \textbf{\lr{Env}} :
	این لایه یک آبجکت از کلاس 
	\lr{Environment}
	را دریافت می‌کند و تمامی نیاز های خود را در مورد هر مسیله‌ای که به ارتباط با محیط متلب و یا سیمولینک به آن واگذار می‌کند و تمرکز آن برروی مفاهیم یادگیری تقویتی مانند 
	\begin{enuminline}
		\item \w{obsspace}
		\item \w{actionspace}
		\item  تعریف حرکت
		\item تعریف حالت 
		\item تعریف امتیاز
	\end{enuminline} 
	و ... می‌باشد.
	
	
	\item \textbf{\lr{gym}} :
	در نهایت یک مجموعه داریم که هر یک وظایف مربوط به خود را دارند. در این قسمت کد ما که در لایه \lr{Env} به \lr{gym} نزدیک شده است، با فراخوانی لایه های پیشین به ترتیب از بالا به پایین (از نظر سطح) فراخوانی می‌شود و در هر لایه آبجکت‌هایی از کلاس‌های موجود در لایه پایین تر فراخوانی می‌شود. از این رو جهت پیکان بر عکس است. 
	
	در مورد \lr{gym} در فصل 
	\ref{ch:req}
	به صورت مفصل بحث شده‌است.
	
	\item \textbf{\lr{Algorithm}} :
	در لایه های پیشین سینتکس کد \lr{gym} ایجاد شده است و این لایه بر توسعه الگوریتم های یادگیری تقویتی که در فصل 
	\ref{ch:rl}
	مورد بررسی مفصل قرار گرفته است، تمرکز دارد.
	
	می‌توان گفت این لایه نقش رییس و یا مغز کار را دارد و باقی لایه ها کارگرانی هستند که وظیفه دارند که اطلاعات را به شکلی مناسب این لایه، برای آن منتقل کنند.
\end{circlelist}	


\section{بررسی دقیق تر برخی چالش های فنی پروژه}\label{ch:fani|sec:chalenges}

یکی از مهمترین چالش های این پروژه برقرار ارتباط محیط شبیه سازی سیمولینک با پایتون بود. با استفاده از بلوک \lr{UDP Send} می‌توان یک یا چند داده هم نوع را منتقل کرد. این کار از لحاظ فنی، موضوع انتقال را دشوار کرده بود. زیرا یا باید برای هر دیتا، یک بلوک فرستنده قرار داد و یا باید همه دیتا ها را به یک نوع تبدیل کرد و سپس اطلاعات به ترتیب خاصی برای فرستنده فرستاد. 

روش دوم دو تا مشکل دارد یکی آن‌که به شدت به ترتیب قرار گیری دیتا وابسته خواهد شد و دیباگ آن بسیار سخت می‌شود. دوم آنکه از دیتای ارسالی هیچ مفهومی را نمی‌توان بدون داشتن آن ترتیب استخراج نمود و به عبارت دیگر اصلا ماژولار نخواهد بود و کد بسیار نامفهوم و سخت خواهد شد و در صورت توسعه بخش فنی عملا کار از اول شروع می‌شود.

برای حل این مشکلات بلوکی به نام \lr{Environment} در نظر گرفته شد که هرگونه ارتباط با پایتون توسط این بلوک رخ می‌دهد. سپس در قسمت فرستنده یک تابع پیش‌پردازنده تعبیه شد تا داده ها را جمع آوری و ساختار دهی کند. ساختار استفاده شده \lr{json} است که در شکل \ref{fig:json-total} معرفی شد. این ساختار، کد را به شدت ماژولار می‌کند.

نکته خیلی مهم در استفاده از این ساختار این است که این ساختار به شکل رشته می‌باشد. از آنجایی که در سیمولینک باید ابعاد ماتریس ورودی و خروجی مشخص باشد و از آنجایی که متلب رشته را مانند یک بردار با طول متغیر می‌بیند بنابراین محیط سیمولینک به محض آن که خروجی و یا ورودی داده ای از جنس کاراکتر باشد، پیغام خطا می‌دهد.

روشی که برای دور زدن این مورد به کار رفت؛ به شرح زیر است.

\begin{enumerate}
	\item 
	طول ساختار جیسون بر حسب کاراکتر باید ثابت شود. برای این کار لازم شد که طول اعداد نیز ثابت شود.
	\item 
		خروجی به \texttt{uint8} تبدیل شد. زیرا دیگر جنس آن کاراکتر نیست ولی از لحاظ حافظه دقیقا برابر \texttt{char} می‌باشد.
	
\end{enumerate} 

خروجی تابع پیش‌پردازنده به صورت زیر خواهد بود.


\code[json,label={code:json}]{structure-string.json}


در این ساختار اعداد هر محدوده ای که داشته باشد با طول و دقت مشخص در کنار یک دیگر قرار می‌گیرند. بنابراین این مشکل نیز حل می‌شود. 

 